/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * For all asset types, set to:
 *
 * @remarks
 * - manual to add the uploaded asset to a list of pending assets that can be moderated using the Admin API or the Cloudinary Console.
 * - perception_point to automatically moderate the uploaded asset using the Perception Point Malware Detection add-on.
 *
 * For images only, set to:
 * - webpurify to automatically moderate the uploaded image using the WebPurify Image Moderation add-on.
 * - aws_rek to automatically moderate the uploaded image using the Amazon Rekognition AI Moderation add-on.
 * - duplicate:<threshold> to detect if the same or a similar image already exists using the Cloudinary Duplicate Image Detection add-on. Set threshold to a float greater than 0 and less than or equal to 1.0 to specify how similar an image needs to be in order to be considered a duplicate. Set threshold to 0 to add an image to the index of images that are searched when duplicate detection is invoked for another image.
 *
 * For videos only, set to:
 * - aws_rek_video to automatically moderate the uploaded video using the Amazon Rekognition Video Moderation add-on.
 * - google_video_moderation automatically moderate the uploaded video using the Google AI Video Moderation add-on.
 *
 * To request multiple moderations in a single API call:
 * - Send the desired list of moderations as a pipe-separated string with manual moderation, if relevant, being last.
 *
 * Note: Rejected assets are automatically invalidated on the CDN within approximately ten minutes.
 */
export const Moderation = {
  Manual: "manual",
  Webpurify: "webpurify",
  Metascan: "metascan",
  AwsRek: "aws_rek",
  AwsRekVideo: "aws_rek_video",
  GoogleVideoModeration: "google_video_moderation",
  PerceptionPoint: "perception_point",
  Duplicate: "duplicate",
  Cld: "cld",
} as const;
/**
 * For all asset types, set to:
 *
 * @remarks
 * - manual to add the uploaded asset to a list of pending assets that can be moderated using the Admin API or the Cloudinary Console.
 * - perception_point to automatically moderate the uploaded asset using the Perception Point Malware Detection add-on.
 *
 * For images only, set to:
 * - webpurify to automatically moderate the uploaded image using the WebPurify Image Moderation add-on.
 * - aws_rek to automatically moderate the uploaded image using the Amazon Rekognition AI Moderation add-on.
 * - duplicate:<threshold> to detect if the same or a similar image already exists using the Cloudinary Duplicate Image Detection add-on. Set threshold to a float greater than 0 and less than or equal to 1.0 to specify how similar an image needs to be in order to be considered a duplicate. Set threshold to 0 to add an image to the index of images that are searched when duplicate detection is invoked for another image.
 *
 * For videos only, set to:
 * - aws_rek_video to automatically moderate the uploaded video using the Amazon Rekognition Video Moderation add-on.
 * - google_video_moderation automatically moderate the uploaded video using the Google AI Video Moderation add-on.
 *
 * To request multiple moderations in a single API call:
 * - Send the desired list of moderations as a pipe-separated string with manual moderation, if relevant, being last.
 *
 * Note: Rejected assets are automatically invalidated on the CDN within approximately ten minutes.
 */
export type Moderation = ClosedEnum<typeof Moderation>;

export type ResponsiveBreakpoint = {
  createDerived?: boolean | undefined;
  maxWidth?: number | undefined;
  minWidth?: number | undefined;
  bytesStep?: number | undefined;
  maxImages?: number | undefined;
  transformation?: string | undefined;
};

/**
 * The delivery type that defines if and how the uploaded asset is available for public delivery. By default, all uploaded assets are public (upload). Possible values are upload, authenticated, private or asset.
 */
export const UploadPresetType = {
  Upload: "upload",
  Authenticated: "authenticated",
  Private: "private",
  Asset: "asset",
} as const;
/**
 * The delivery type that defines if and how the uploaded asset is available for public delivery. By default, all uploaded assets are public (upload). Possible values are upload, authenticated, private or asset.
 */
export type UploadPresetType = ClosedEnum<typeof UploadPresetType>;

/**
 * Allows the asset to behave as if it's of the authenticated 'type' (see above) while still using the default 'upload' type in delivery URLs. The asset can later be made public by changing its access_mode via the Admin API, without having to update any delivery URLs. Valid values: public, and authenticated.
 *
 * @remarks
 *
 * @deprecated enum: The access_mode parameter is no longer supported. To restrict access to assets, you can use the access_control parameter.. Use accessControl instead.
 */
export const AccessMode = {
  Public: "public",
  Authenticated: "authenticated",
} as const;
/**
 * Allows the asset to behave as if it's of the authenticated 'type' (see above) while still using the default 'upload' type in delivery URLs. The asset can later be made public by changing its access_mode via the Admin API, without having to update any delivery URLs. Valid values: public, and authenticated.
 *
 * @remarks
 *
 * @deprecated enum: The access_mode parameter is no longer supported. To restrict access to assets, you can use the access_control parameter.. Use accessControl instead.
 */
export type AccessMode = ClosedEnum<typeof AccessMode>;

/**
 * A comma-separated list of the categorization add-ons to run on the asset. Set to google_tagging, google_video_tagging, imagga_tagging and/or aws_rek_tagging to automatically classify the scenes of the uploaded asset.
 */
export const Categorization = {
  RekognitionScene: "rekognition_scene",
  ImaggaTagging: "imagga_tagging",
  AwsRekTagging: "aws_rek_tagging",
  GoogleVideoTagging: "google_video_tagging",
  GoogleTagging: "google_tagging",
  VisenzeRecognition: "visenze_recognition",
  AzureVideoIndexer: "azure_video_indexer",
} as const;
/**
 * A comma-separated list of the categorization add-ons to run on the asset. Set to google_tagging, google_video_tagging, imagga_tagging and/or aws_rek_tagging to automatically classify the scenes of the uploaded asset.
 */
export type Categorization = ClosedEnum<typeof Categorization>;

/**
 * Set to adv_ocr to extract all text elements in an image as well as the bounding box coordinates of each detected element using the OCR text detection and extraction add-on.
 */
export const Ocr = {
  AdvOcr: "adv_ocr",
} as const;
/**
 * Set to adv_ocr to extract all text elements in an image as well as the bounding box coordinates of each detected element using the OCR text detection and extraction add-on.
 */
export type Ocr = ClosedEnum<typeof Ocr>;

/**
 * Automatically remove the background of an image using an add-on.
 *
 * @remarks
 * - Set to cloudinary_ai to use the deep-learning based Cloudinary AI Background Removal add-on.
 * - Note: this feature has been superseded by background removal on the fly.
 * - Set to pixelz to use the human-powered Pixelz Remove-The-Background Editing add-on service.
 * Relevant for images only.
 */
export const BackgroundRemoval = {
  CloudinaryAi: "cloudinary_ai",
  RemoveTheBackground: "remove_the_background",
  Pixelz: "pixelz",
} as const;
/**
 * Automatically remove the background of an image using an add-on.
 *
 * @remarks
 * - Set to cloudinary_ai to use the deep-learning based Cloudinary AI Background Removal add-on.
 * - Note: this feature has been superseded by background removal on the fly.
 * - Set to pixelz to use the human-powered Pixelz Remove-The-Background Editing add-on service.
 * Relevant for images only.
 */
export type BackgroundRemoval = ClosedEnum<typeof BackgroundRemoval>;

export type UploadPreset = {
  /**
   * Whether to return return accessibility analysis values for the image.
   */
  accessibilityAnalysis?: boolean | undefined;
  /**
   * The asset folder to assign to the asset.
   */
  assetFolder?: string | undefined;
  /**
   * When set to true, returns the uploaded asset's public_id immediately in the response, before the upload is completed (asynchronously). Default: false.
   *
   * @remarks
   */
  async?: boolean | undefined;
  /**
   * Whether to trigger automatic generation of video chapters. Chapters will be generated and saved as a .vtt file with -chapters appended to the public ID of the video. You can enable chapters as part of the Cloudinary Video Player. Relevant for videos only.
   */
  autoChaptering?: boolean | undefined;
  /**
   * Whether to trigger automatic generation of video transcription. Transcription will be generated and saved as a .vtt file with -transcription appended to the public ID of the video. Relevant for videos only.
   */
  autoTranscription?: boolean | undefined;
  /**
   * Whether to return a cinemagraph analysis value for the media asset between 0 and 1, where 0 means the asset is not a cinemagraph and 1 means the asset is a cinemagraph. Relevant for animated images and video only. A static image will return 0.
   */
  cinemagraphAnalysis?: boolean | undefined;
  /**
   * Whether to retrieve predominant colors & color histogram of the uploaded image. Note: If all returned colors are opaque, then 6-digit RGB hex values are returned. If one or more colors contain an alpha channel, then 8-digit RGBA hex quadruplet values are returned.
   */
  colors?: boolean | undefined;
  /**
   * Key-value pairs of general textual context metadata to attach to the asset.
   */
  context?: string | undefined;
  /**
   * An array of coordinates for custom cropping.
   */
  customCoordinates?: string | undefined;
  /**
   * A display name for the asset.
   */
  displayName?: string | undefined;
  /**
   * A list of transformations to eagerly generate for the asset. Accepts either a single transformation or a pipe-separated list of transformations.
   */
  eager?: string | undefined;
  /**
   * Whether to generate the eager transformations asynchronously in the background after the upload request is completed rather than before the upload is completed.
   */
  eagerAsync?: boolean | undefined;
  /**
   * A URL to notify when eager transformations are completed.
   */
  eagerNotificationUrl?: string | undefined;
  /**
   * An array of coordinates representing detected faces in the asset, used for custom cropping or overlays.
   */
  faceCoordinates?: string | undefined;
  /**
   * Whether to detect faces in the asset.
   */
  faces?: boolean | undefined;
  /**
   * An HTTP header or a list of headers lines for adding as response HTTP headers when delivering the asset to your users. Supported headers: Link, Authorization, X-Robots-Tag.
   *
   * @remarks
   */
  headers?: string | undefined;
  /**
   * Whether to invalidate CDN cache copies of a previously uploaded asset that shares the same public ID. Default: false.
   *
   * @remarks
   */
  invalidate?: boolean | undefined;
  /**
   * Whether to return IPTC, XMP, and detailed Exif metadata of the uploaded asset in the response.
   *
   * @remarks
   * Supported for images, video, and audio.
   * - Returned metadata for images includes: PixelsPerUnitX, PixelsPerUnitY, PixelUnits, Colorspace, and DPI.
   * - Returned metadata for audio and video includes: audio_codec, audio_bit_rate, audio_frequency, channels, channel_layout.
   * - Additional metadata for video includes: pix_format, codec, level, profile, video_bit_rate, dar.
   */
  mediaMetadata?: boolean | undefined;
  /**
   * Structured metadata to attach to the asset based on the metadata fields defined for your account.
   */
  metadata?: string | undefined;
  /**
   * For all asset types, set to:
   *
   * @remarks
   * - manual to add the uploaded asset to a list of pending assets that can be moderated using the Admin API or the Cloudinary Console.
   * - perception_point to automatically moderate the uploaded asset using the Perception Point Malware Detection add-on.
   *
   * For images only, set to:
   * - webpurify to automatically moderate the uploaded image using the WebPurify Image Moderation add-on.
   * - aws_rek to automatically moderate the uploaded image using the Amazon Rekognition AI Moderation add-on.
   * - duplicate:<threshold> to detect if the same or a similar image already exists using the Cloudinary Duplicate Image Detection add-on. Set threshold to a float greater than 0 and less than or equal to 1.0 to specify how similar an image needs to be in order to be considered a duplicate. Set threshold to 0 to add an image to the index of images that are searched when duplicate detection is invoked for another image.
   *
   * For videos only, set to:
   * - aws_rek_video to automatically moderate the uploaded video using the Amazon Rekognition Video Moderation add-on.
   * - google_video_moderation automatically moderate the uploaded video using the Google AI Video Moderation add-on.
   *
   * To request multiple moderations in a single API call:
   * - Send the desired list of moderations as a pipe-separated string with manual moderation, if relevant, being last.
   *
   * Note: Rejected assets are automatically invalidated on the CDN within approximately ten minutes.
   */
  moderation?: Moderation | undefined;
  /**
   * A URL to notify when the asset is ready.
   */
  notificationUrl?: string | undefined;
  /**
   * Whether to return the perceptual hash (pHash) on the uploaded image for image similarity detection.
   *
   * @remarks
   */
  phash?: boolean | undefined;
  /**
   * Whether to return a quality analysis value for the image between 0 and 1, where 0 means the image is blurry and out of focus and 1 means the image is sharp and in focus. Relevant for images only.
   */
  qualityAnalysis?: boolean | undefined;
  /**
   * Regions to detect in the asset.
   */
  regions?: string | undefined;
  /**
   * Settings to automatically generate breakpoints for responsive images.
   */
  responsiveBreakpoints?: Array<ResponsiveBreakpoint> | undefined;
  /**
   * A comma-separated list of tag names to assign to the asset.
   */
  tags?: string | undefined;
  /**
   * A URL to redirect to after the upload/explicit is completed instead of returning the upload response.
   *
   * @remarks
   * Signed upload result parameters are added to the callback URL. This parameter is ignored for XHR (Ajax XMLHttpRequest) or JavaScript Fetch API upload requests.
   * Note: This parameter is relevant for direct uploads from a form in the browser. It is automatically set if you perform direct upload from the browser using Cloudinary's SDKs and the jQuery plugin.
   */
  callback?: string | undefined;
  /**
   * Whether to backup the uploaded asset. When set to true, backs up uploaded assets to a secondary storage bucket.
   */
  backup?: boolean | undefined;
  /**
   * Whether to discard the name of the original uploaded file. Relevant when delivering assets as attachments (setting the flag disposition:attachment in delivery URLs).
   */
  discardOriginalFilename?: boolean | undefined;
  /**
   * Whether to overwrite existing assets with the same public ID. When set to false, return immediately if an asset with the same public ID already exists. Default: true (when using unsigned upload, the default is false and cannot be changed to true).
   *
   * @remarks
   */
  overwrite?: boolean | undefined;
  /**
   * Whether to return a deletion token in the upload response. The token can be used to delete the uploaded asset within approximately 10 minutes using an unauthenticated API call.
   */
  returnDeleteToken?: boolean | undefined;
  /**
   * The delivery type that defines if and how the uploaded asset is available for public delivery. By default, all uploaded assets are public (upload). Possible values are upload, authenticated, private or asset.
   */
  type?: UploadPresetType | undefined;
  /**
   * Allows the asset to behave as if it's of the authenticated 'type' (see above) while still using the default 'upload' type in delivery URLs. The asset can later be made public by changing its access_mode via the Admin API, without having to update any delivery URLs. Valid values: public, and authenticated.
   *
   * @remarks
   *
   * @deprecated field: The access_mode parameter is no longer supported. To restrict access to assets, you can use the access_control parameter.. Use accessControl instead.
   */
  accessMode?: AccessMode | undefined;
  /**
   * A comma-separated list of the categorization add-ons to run on the asset. Set to google_tagging, google_video_tagging, imagga_tagging and/or aws_rek_tagging to automatically classify the scenes of the uploaded asset.
   */
  categorization?: Categorization | undefined;
  /**
   * Set to adv_ocr to extract all text elements in an image as well as the bounding box coordinates of each detected element using the OCR text detection and extraction add-on.
   */
  ocr?: Ocr | undefined;
  /**
   * Generates a related file based on the uploaded file.
   *
   * @remarks
   * - Set to aspose to automatically create a PDF or other image format from a raw Office document using the Aspose Document Conversion add-on. (Asynchronous)
   * - Set to google_speech to instruct the Google AI Video Transcription add-on to generate an automatic transcript raw file from an uploaded video. (Asynchronous)
   * - Set to extract_text to extract all the text from a PDF file and store it in a raw JSON file with a public ID in the format: [pdf_public_id].extract_text.json. The full URL of the generated JSON file is included in the API response. Unlike the above raw_convert options, this option doesn't require registering for an add-on.(Synchronous)
   * - Set to azure_video_indexer to generate AI-powered video insights from Microsoft Azure. (Asynchronous)
   */
  rawConvert?: string | undefined;
  /**
   * Automatically remove the background of an image using an add-on.
   *
   * @remarks
   * - Set to cloudinary_ai to use the deep-learning based Cloudinary AI Background Removal add-on.
   * - Note: this feature has been superseded by background removal on the fly.
   * - Set to pixelz to use the human-powered Pixelz Remove-The-Background Editing add-on service.
   * Relevant for images only.
   */
  backgroundRemoval?: BackgroundRemoval | undefined;
  /**
   * The identifier that is used for accessing the uploaded asset. If not specified, a unique ID is generated automatically.
   */
  publicId?: string | undefined;
  /**
   * An incoming transformation to run on the uploaded asset before its storage. In contrast to eager, this parameter is applied before the file is stored.
   */
  transformation?: string | undefined;
  /**
   * An optional format to convert the uploaded asset to before saving in the cloud.
   */
  format?: string | undefined;
  /**
   * A proxy to use for fetching remote URLs. The format should be http://hostname:port.
   */
  proxy?: string | undefined;
  /**
   * Folder name where the uploaded asset will be stored. This parameter applies when using the Admin API, or when specifying the upload preset for unsigned uploading with the Upload API.
   *
   * @deprecated field: If Dynamic folders mode is enabled on your product environment, this parameter is deprecated, and it's recommended to use the asset_folder parameter to control where the asset will be placed. If you also want your public_id to match the initial asset folder path, include the use_asset_folder_as_public_id_prefixparameter.
  .
   */
  folder?: string | undefined;
  /**
   * A comma-separated list of file formats that are allowed for uploading. Files of other types will be rejected. The formats can be any combination of image types, video formats or raw file extensions.
   *
   * @remarks
   * Note: You can also add the `format` parameter to convert other file types instead of rejecting them. In this case, only files that would normally be rejected are converted, any file format allowed for upload wont be converted.
   */
  allowedFormats?: string | undefined;
  /**
   * Automatically assigns tags to an asset according to detected objects or categories with a confidence score higher than the specified value.
   *
   * @remarks
   * Use together with the detection parameter for:
   * - Cloudinary AI Content Analysis
   * - Amazon Rekognition Celebrity Detection
   * Use together with the categorization parameter for:
   * - Google Automatic Video Tagging
   * - Google Auto Tagging
   * - Imagga Auto Tagging
   * - Amazon Rekognition Auto Tagging
   */
  autoTagging?: number | undefined;
  /**
   * Restrict access to the asset by passing an array of access types for the asset. The asset is restricted unless one of the access types is valid.
   *
   * @remarks
   * Possible values for each access type:
   * - token requires either Token-based access or Cookie-based access for accessing the asset.
   * For example: access_type: "token"
   * - anonymous allows public access to the asset during a set time period. The anonymous access type can optionally include start and/or end dates (in ISO 8601 format) that define when the asset is publicly available. Note that you can only include a single 'anonymous' access type. For example:
   * access_type: "anonymous", start: "2017-12-15T12:00Z", end: "2018-01-20T12:00Z"
   */
  accessControl?: string | undefined;
  /**
   * Allows you to modify upload parameters by specifying custom logic with JavaScript. This can be useful for conditionally adding tags, contextual metadata, structured metadata or eager transformations depending on specific criteria of the uploaded file.
   */
  eval?: string | undefined;
  /**
   * Invokes the relevant add-on to return a list of detected content.
   *
   * @remarks
   * Set to:
   * - <content-aware model>_[<version>] (e.g. coco_v2) to return a list of detected content using the Cloudinary AI Content Analysis add-on. Can be used together with the auto_tagging parameter to apply tags automatically.
   * - captioning to analyze an image and suggest a caption based on the image's contents.
   * - iqa to analyze the quality of an image.
   * - watermark-detection to detect watermarks in an image.
   * - adv_face to return a list of facial attributes using the Advanced Facial Attribute Detection add-on.
   * - aws_rek_face to return a list of detected celebrities and facial attributes using the Amazon Rekognition Celebrity Detection add-on. Can be used together with the auto_tagging parameter to apply tags automatically.
   */
  detection?: string | undefined;
  /**
   * Overrides the originally uploaded asset's file name in downloads that use flags like fl_attachment or fl_force_original.
   */
  filenameOverride?: string | undefined;
  /**
   * A string or path that's automatically prepended to the public_id with a forward slash. The value can contain the same characters as the public_id including additional forward slashes. This prefix can be useful to provide context and improve the SEO of an asset's filename in the delivery URL, but the value does not impact the location where the asset is stored.
   */
  publicIdPrefix?: string | undefined;
  /**
   * Whether to add the asset_folder value as a prefix to the public_id value (prepended with a forward slash). This ensures that the public ID path will always match the initial asset folder, and can help to retain the behavior that previously existed in fixed folder mode. However, keep in mind that even when this option is used during upload, an asset with a certain public ID path can later be moved to a completely different asset folder hierarchy without impacting the public ID. This option only ensures path matching for the initial upload. Relevant only when public_id_prefix (or folder) has not been separately specified.
   */
  useAssetFolderAsPublicIdPrefix?: boolean | undefined;
  /**
   * Whether the display name should be unique.
   */
  uniqueDisplayName?: boolean | undefined;
  /**
   * Whether to index the image for use with visual searches. Relevant for images only.
   */
  visualSearch?: boolean | undefined;
  /**
   * Whether to automatically assign the original filename of the uploaded asset as the asset's display name. Relevant only if the display_name parameter isn't set.
   */
  useFilenameAsDisplayName?: boolean | undefined;
  /**
   * Whether to use the original file name of the uploaded asset if available for the public ID. The file name is normalized and random characters are appended to ensure uniqueness if the file name already exists. Default: false.
   *
   * @remarks
   */
  useFilename?: boolean | undefined;
  /**
   * When set to false and used together with use_filename, if an asset with the same file name already exists, no random characters are appended to the file name. Instead, the asset is overwritten. Default: true (random characters are added to the file name if needed).
   *
   * @remarks
   */
  uniqueFilename?: boolean | undefined;
  /**
   * Name of an upload preset that you defined for your Cloudinary product environment. An upload preset consists of upload parameters centrally managed using the Admin API or from the Upload Presets page of the Console Settings.
   */
  uploadPreset?: string | undefined;
  /**
   * Allows you to update an asset by specifying custom logic with JavaScript that is executed after the upload to Cloudinary is completed successfully. This can be useful for conditionally adding tags, contextual metadata, and structured metadata, depending on the results of using the detection parameter on upload.
   */
  onSuccess?: string | undefined;
  /**
   * The name of the upload preset when creating or modifying an upload preset.
   */
  name?: string | undefined;
  /**
   * When using unsigned upload with an upload preset, this parameter prevents specifying a public ID. Relevant only for unsigned upload presets.
   *
   * @remarks
   */
  disallowPublicId?: boolean | undefined;
  /**
   * Whether the upload preset allows unsigned uploads.
   */
  unsigned?: boolean | undefined;
};

/** @internal */
export const Moderation$inboundSchema: z.ZodNativeEnum<typeof Moderation> = z
  .nativeEnum(Moderation);

/** @internal */
export const Moderation$outboundSchema: z.ZodNativeEnum<typeof Moderation> =
  Moderation$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Moderation$ {
  /** @deprecated use `Moderation$inboundSchema` instead. */
  export const inboundSchema = Moderation$inboundSchema;
  /** @deprecated use `Moderation$outboundSchema` instead. */
  export const outboundSchema = Moderation$outboundSchema;
}

/** @internal */
export const ResponsiveBreakpoint$inboundSchema: z.ZodType<
  ResponsiveBreakpoint,
  z.ZodTypeDef,
  unknown
> = z.object({
  create_derived: z.boolean().optional(),
  max_width: z.number().int().optional(),
  min_width: z.number().int().optional(),
  bytes_step: z.number().int().optional(),
  max_images: z.number().int().optional(),
  transformation: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "create_derived": "createDerived",
    "max_width": "maxWidth",
    "min_width": "minWidth",
    "bytes_step": "bytesStep",
    "max_images": "maxImages",
  });
});

/** @internal */
export type ResponsiveBreakpoint$Outbound = {
  create_derived?: boolean | undefined;
  max_width?: number | undefined;
  min_width?: number | undefined;
  bytes_step?: number | undefined;
  max_images?: number | undefined;
  transformation?: string | undefined;
};

/** @internal */
export const ResponsiveBreakpoint$outboundSchema: z.ZodType<
  ResponsiveBreakpoint$Outbound,
  z.ZodTypeDef,
  ResponsiveBreakpoint
> = z.object({
  createDerived: z.boolean().optional(),
  maxWidth: z.number().int().optional(),
  minWidth: z.number().int().optional(),
  bytesStep: z.number().int().optional(),
  maxImages: z.number().int().optional(),
  transformation: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    createDerived: "create_derived",
    maxWidth: "max_width",
    minWidth: "min_width",
    bytesStep: "bytes_step",
    maxImages: "max_images",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResponsiveBreakpoint$ {
  /** @deprecated use `ResponsiveBreakpoint$inboundSchema` instead. */
  export const inboundSchema = ResponsiveBreakpoint$inboundSchema;
  /** @deprecated use `ResponsiveBreakpoint$outboundSchema` instead. */
  export const outboundSchema = ResponsiveBreakpoint$outboundSchema;
  /** @deprecated use `ResponsiveBreakpoint$Outbound` instead. */
  export type Outbound = ResponsiveBreakpoint$Outbound;
}

export function responsiveBreakpointToJSON(
  responsiveBreakpoint: ResponsiveBreakpoint,
): string {
  return JSON.stringify(
    ResponsiveBreakpoint$outboundSchema.parse(responsiveBreakpoint),
  );
}

export function responsiveBreakpointFromJSON(
  jsonString: string,
): SafeParseResult<ResponsiveBreakpoint, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponsiveBreakpoint$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponsiveBreakpoint' from JSON`,
  );
}

/** @internal */
export const UploadPresetType$inboundSchema: z.ZodNativeEnum<
  typeof UploadPresetType
> = z.nativeEnum(UploadPresetType);

/** @internal */
export const UploadPresetType$outboundSchema: z.ZodNativeEnum<
  typeof UploadPresetType
> = UploadPresetType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UploadPresetType$ {
  /** @deprecated use `UploadPresetType$inboundSchema` instead. */
  export const inboundSchema = UploadPresetType$inboundSchema;
  /** @deprecated use `UploadPresetType$outboundSchema` instead. */
  export const outboundSchema = UploadPresetType$outboundSchema;
}

/** @internal */
export const AccessMode$inboundSchema: z.ZodNativeEnum<typeof AccessMode> = z
  .nativeEnum(AccessMode);

/** @internal */
export const AccessMode$outboundSchema: z.ZodNativeEnum<typeof AccessMode> =
  AccessMode$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AccessMode$ {
  /** @deprecated use `AccessMode$inboundSchema` instead. */
  export const inboundSchema = AccessMode$inboundSchema;
  /** @deprecated use `AccessMode$outboundSchema` instead. */
  export const outboundSchema = AccessMode$outboundSchema;
}

/** @internal */
export const Categorization$inboundSchema: z.ZodNativeEnum<
  typeof Categorization
> = z.nativeEnum(Categorization);

/** @internal */
export const Categorization$outboundSchema: z.ZodNativeEnum<
  typeof Categorization
> = Categorization$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Categorization$ {
  /** @deprecated use `Categorization$inboundSchema` instead. */
  export const inboundSchema = Categorization$inboundSchema;
  /** @deprecated use `Categorization$outboundSchema` instead. */
  export const outboundSchema = Categorization$outboundSchema;
}

/** @internal */
export const Ocr$inboundSchema: z.ZodNativeEnum<typeof Ocr> = z.nativeEnum(Ocr);

/** @internal */
export const Ocr$outboundSchema: z.ZodNativeEnum<typeof Ocr> =
  Ocr$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Ocr$ {
  /** @deprecated use `Ocr$inboundSchema` instead. */
  export const inboundSchema = Ocr$inboundSchema;
  /** @deprecated use `Ocr$outboundSchema` instead. */
  export const outboundSchema = Ocr$outboundSchema;
}

/** @internal */
export const BackgroundRemoval$inboundSchema: z.ZodNativeEnum<
  typeof BackgroundRemoval
> = z.nativeEnum(BackgroundRemoval);

/** @internal */
export const BackgroundRemoval$outboundSchema: z.ZodNativeEnum<
  typeof BackgroundRemoval
> = BackgroundRemoval$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BackgroundRemoval$ {
  /** @deprecated use `BackgroundRemoval$inboundSchema` instead. */
  export const inboundSchema = BackgroundRemoval$inboundSchema;
  /** @deprecated use `BackgroundRemoval$outboundSchema` instead. */
  export const outboundSchema = BackgroundRemoval$outboundSchema;
}

/** @internal */
export const UploadPreset$inboundSchema: z.ZodType<
  UploadPreset,
  z.ZodTypeDef,
  unknown
> = z.object({
  accessibility_analysis: z.boolean().optional(),
  asset_folder: z.string().optional(),
  async: z.boolean().optional(),
  auto_chaptering: z.boolean().optional(),
  auto_transcription: z.boolean().optional(),
  cinemagraph_analysis: z.boolean().optional(),
  colors: z.boolean().default(false),
  context: z.string().optional(),
  custom_coordinates: z.string().optional(),
  display_name: z.string().optional(),
  eager: z.string().optional(),
  eager_async: z.boolean().optional(),
  eager_notification_url: z.string().optional(),
  face_coordinates: z.string().optional(),
  faces: z.boolean().optional(),
  headers: z.string().optional(),
  invalidate: z.boolean().optional(),
  media_metadata: z.boolean().optional(),
  metadata: z.string().optional(),
  moderation: Moderation$inboundSchema.optional(),
  notification_url: z.string().optional(),
  phash: z.boolean().optional(),
  quality_analysis: z.boolean().optional(),
  regions: z.string().optional(),
  responsive_breakpoints: z.array(
    z.lazy(() => ResponsiveBreakpoint$inboundSchema),
  ).optional(),
  tags: z.string().optional(),
  callback: z.string().optional(),
  backup: z.boolean().optional(),
  discard_original_filename: z.boolean().optional(),
  overwrite: z.boolean().optional(),
  return_delete_token: z.boolean().optional(),
  type: UploadPresetType$inboundSchema.optional(),
  access_mode: AccessMode$inboundSchema.optional(),
  categorization: Categorization$inboundSchema.optional(),
  ocr: Ocr$inboundSchema.optional(),
  raw_convert: z.string().optional(),
  background_removal: BackgroundRemoval$inboundSchema.optional(),
  public_id: z.string().optional(),
  transformation: z.string().optional(),
  format: z.string().optional(),
  proxy: z.string().optional(),
  folder: z.string().optional(),
  allowed_formats: z.string().optional(),
  auto_tagging: z.number().optional(),
  access_control: z.string().optional(),
  eval: z.string().optional(),
  detection: z.string().optional(),
  filename_override: z.string().optional(),
  public_id_prefix: z.string().optional(),
  use_asset_folder_as_public_id_prefix: z.boolean().optional(),
  unique_display_name: z.boolean().optional(),
  visual_search: z.boolean().optional(),
  use_filename_as_display_name: z.boolean().optional(),
  use_filename: z.boolean().optional(),
  unique_filename: z.boolean().optional(),
  upload_preset: z.string().optional(),
  on_success: z.string().optional(),
  name: z.string().optional(),
  disallow_public_id: z.boolean().optional(),
  unsigned: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "accessibility_analysis": "accessibilityAnalysis",
    "asset_folder": "assetFolder",
    "auto_chaptering": "autoChaptering",
    "auto_transcription": "autoTranscription",
    "cinemagraph_analysis": "cinemagraphAnalysis",
    "custom_coordinates": "customCoordinates",
    "display_name": "displayName",
    "eager_async": "eagerAsync",
    "eager_notification_url": "eagerNotificationUrl",
    "face_coordinates": "faceCoordinates",
    "media_metadata": "mediaMetadata",
    "notification_url": "notificationUrl",
    "quality_analysis": "qualityAnalysis",
    "responsive_breakpoints": "responsiveBreakpoints",
    "discard_original_filename": "discardOriginalFilename",
    "return_delete_token": "returnDeleteToken",
    "access_mode": "accessMode",
    "raw_convert": "rawConvert",
    "background_removal": "backgroundRemoval",
    "public_id": "publicId",
    "allowed_formats": "allowedFormats",
    "auto_tagging": "autoTagging",
    "access_control": "accessControl",
    "filename_override": "filenameOverride",
    "public_id_prefix": "publicIdPrefix",
    "use_asset_folder_as_public_id_prefix": "useAssetFolderAsPublicIdPrefix",
    "unique_display_name": "uniqueDisplayName",
    "visual_search": "visualSearch",
    "use_filename_as_display_name": "useFilenameAsDisplayName",
    "use_filename": "useFilename",
    "unique_filename": "uniqueFilename",
    "upload_preset": "uploadPreset",
    "on_success": "onSuccess",
    "disallow_public_id": "disallowPublicId",
  });
});

/** @internal */
export type UploadPreset$Outbound = {
  accessibility_analysis?: boolean | undefined;
  asset_folder?: string | undefined;
  async?: boolean | undefined;
  auto_chaptering?: boolean | undefined;
  auto_transcription?: boolean | undefined;
  cinemagraph_analysis?: boolean | undefined;
  colors: boolean;
  context?: string | undefined;
  custom_coordinates?: string | undefined;
  display_name?: string | undefined;
  eager?: string | undefined;
  eager_async?: boolean | undefined;
  eager_notification_url?: string | undefined;
  face_coordinates?: string | undefined;
  faces?: boolean | undefined;
  headers?: string | undefined;
  invalidate?: boolean | undefined;
  media_metadata?: boolean | undefined;
  metadata?: string | undefined;
  moderation?: string | undefined;
  notification_url?: string | undefined;
  phash?: boolean | undefined;
  quality_analysis?: boolean | undefined;
  regions?: string | undefined;
  responsive_breakpoints?: Array<ResponsiveBreakpoint$Outbound> | undefined;
  tags?: string | undefined;
  callback?: string | undefined;
  backup?: boolean | undefined;
  discard_original_filename?: boolean | undefined;
  overwrite?: boolean | undefined;
  return_delete_token?: boolean | undefined;
  type?: string | undefined;
  access_mode?: string | undefined;
  categorization?: string | undefined;
  ocr?: string | undefined;
  raw_convert?: string | undefined;
  background_removal?: string | undefined;
  public_id?: string | undefined;
  transformation?: string | undefined;
  format?: string | undefined;
  proxy?: string | undefined;
  folder?: string | undefined;
  allowed_formats?: string | undefined;
  auto_tagging?: number | undefined;
  access_control?: string | undefined;
  eval?: string | undefined;
  detection?: string | undefined;
  filename_override?: string | undefined;
  public_id_prefix?: string | undefined;
  use_asset_folder_as_public_id_prefix?: boolean | undefined;
  unique_display_name?: boolean | undefined;
  visual_search?: boolean | undefined;
  use_filename_as_display_name?: boolean | undefined;
  use_filename?: boolean | undefined;
  unique_filename?: boolean | undefined;
  upload_preset?: string | undefined;
  on_success?: string | undefined;
  name?: string | undefined;
  disallow_public_id?: boolean | undefined;
  unsigned?: boolean | undefined;
};

/** @internal */
export const UploadPreset$outboundSchema: z.ZodType<
  UploadPreset$Outbound,
  z.ZodTypeDef,
  UploadPreset
> = z.object({
  accessibilityAnalysis: z.boolean().optional(),
  assetFolder: z.string().optional(),
  async: z.boolean().optional(),
  autoChaptering: z.boolean().optional(),
  autoTranscription: z.boolean().optional(),
  cinemagraphAnalysis: z.boolean().optional(),
  colors: z.boolean().default(false),
  context: z.string().optional(),
  customCoordinates: z.string().optional(),
  displayName: z.string().optional(),
  eager: z.string().optional(),
  eagerAsync: z.boolean().optional(),
  eagerNotificationUrl: z.string().optional(),
  faceCoordinates: z.string().optional(),
  faces: z.boolean().optional(),
  headers: z.string().optional(),
  invalidate: z.boolean().optional(),
  mediaMetadata: z.boolean().optional(),
  metadata: z.string().optional(),
  moderation: Moderation$outboundSchema.optional(),
  notificationUrl: z.string().optional(),
  phash: z.boolean().optional(),
  qualityAnalysis: z.boolean().optional(),
  regions: z.string().optional(),
  responsiveBreakpoints: z.array(
    z.lazy(() => ResponsiveBreakpoint$outboundSchema),
  ).optional(),
  tags: z.string().optional(),
  callback: z.string().optional(),
  backup: z.boolean().optional(),
  discardOriginalFilename: z.boolean().optional(),
  overwrite: z.boolean().optional(),
  returnDeleteToken: z.boolean().optional(),
  type: UploadPresetType$outboundSchema.optional(),
  accessMode: AccessMode$outboundSchema.optional(),
  categorization: Categorization$outboundSchema.optional(),
  ocr: Ocr$outboundSchema.optional(),
  rawConvert: z.string().optional(),
  backgroundRemoval: BackgroundRemoval$outboundSchema.optional(),
  publicId: z.string().optional(),
  transformation: z.string().optional(),
  format: z.string().optional(),
  proxy: z.string().optional(),
  folder: z.string().optional(),
  allowedFormats: z.string().optional(),
  autoTagging: z.number().optional(),
  accessControl: z.string().optional(),
  eval: z.string().optional(),
  detection: z.string().optional(),
  filenameOverride: z.string().optional(),
  publicIdPrefix: z.string().optional(),
  useAssetFolderAsPublicIdPrefix: z.boolean().optional(),
  uniqueDisplayName: z.boolean().optional(),
  visualSearch: z.boolean().optional(),
  useFilenameAsDisplayName: z.boolean().optional(),
  useFilename: z.boolean().optional(),
  uniqueFilename: z.boolean().optional(),
  uploadPreset: z.string().optional(),
  onSuccess: z.string().optional(),
  name: z.string().optional(),
  disallowPublicId: z.boolean().optional(),
  unsigned: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    accessibilityAnalysis: "accessibility_analysis",
    assetFolder: "asset_folder",
    autoChaptering: "auto_chaptering",
    autoTranscription: "auto_transcription",
    cinemagraphAnalysis: "cinemagraph_analysis",
    customCoordinates: "custom_coordinates",
    displayName: "display_name",
    eagerAsync: "eager_async",
    eagerNotificationUrl: "eager_notification_url",
    faceCoordinates: "face_coordinates",
    mediaMetadata: "media_metadata",
    notificationUrl: "notification_url",
    qualityAnalysis: "quality_analysis",
    responsiveBreakpoints: "responsive_breakpoints",
    discardOriginalFilename: "discard_original_filename",
    returnDeleteToken: "return_delete_token",
    accessMode: "access_mode",
    rawConvert: "raw_convert",
    backgroundRemoval: "background_removal",
    publicId: "public_id",
    allowedFormats: "allowed_formats",
    autoTagging: "auto_tagging",
    accessControl: "access_control",
    filenameOverride: "filename_override",
    publicIdPrefix: "public_id_prefix",
    useAssetFolderAsPublicIdPrefix: "use_asset_folder_as_public_id_prefix",
    uniqueDisplayName: "unique_display_name",
    visualSearch: "visual_search",
    useFilenameAsDisplayName: "use_filename_as_display_name",
    useFilename: "use_filename",
    uniqueFilename: "unique_filename",
    uploadPreset: "upload_preset",
    onSuccess: "on_success",
    disallowPublicId: "disallow_public_id",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UploadPreset$ {
  /** @deprecated use `UploadPreset$inboundSchema` instead. */
  export const inboundSchema = UploadPreset$inboundSchema;
  /** @deprecated use `UploadPreset$outboundSchema` instead. */
  export const outboundSchema = UploadPreset$outboundSchema;
  /** @deprecated use `UploadPreset$Outbound` instead. */
  export type Outbound = UploadPreset$Outbound;
}

export function uploadPresetToJSON(uploadPreset: UploadPreset): string {
  return JSON.stringify(UploadPreset$outboundSchema.parse(uploadPreset));
}

export function uploadPresetFromJSON(
  jsonString: string,
): SafeParseResult<UploadPreset, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UploadPreset$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UploadPreset' from JSON`,
  );
}
