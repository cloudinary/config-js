/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { uploadMappingsListUploadMappings } from "../../funcs/uploadMappingsListUploadMappings.js";
import { formatResult, ToolDefinition } from "../tools.js";

const args = {
  folder: z.string().optional(),
  nextCursor: z.string().optional(),
  maxResults: z.number().int().default(10),
};

export const tool$uploadMappingsListUploadMappings: ToolDefinition<
  typeof args
> = {
  name: "list-upload-mappings",
  description:
    `Purpose: Retrieves all upload mappings configured in your Cloudinary account, which define custom URL structures for accessing assets in specific folders, enabling branded or custom domain delivery patterns.
Usage: Use this to audit existing URL mappings, understand current delivery configurations, troubleshoot URL routing issues, or review mappings before creating new ones. Essential for managing custom domain setups and branded asset delivery.
Example request: GET /upload_mappings?folder=products&max_results=50
Parameters: folder(optional - filter by specific folder), max_results(pagination limit 1-500), next_cursor(pagination token)
When Not to Use: Not needed for standard Cloudinary URL delivery. Avoid frequent polling as mappings change infrequently.
Output: Returns mapping list or single mapping: mappings array containing folder(folder path), template(URL pattern), external_id(unique identifier), created_at(creation time), plus total_entries(count) and next_cursor(pagination) for lists
Example output: {"mappings":[{"folder":"products","template":"https://cdn.example.com/{public_id}","external_id":"map_123","created_at":"2023-01-15T18:00:00Z"}],"total_entries":1}
`,
  scopes: ["builder"],
  args,
  tool: async (client, args, ctx) => {
    const [result, apiCall] = await uploadMappingsListUploadMappings(
      client,
      args.folder,
      args.nextCursor,
      args.maxResults,
      { fetchOptions: { signal: ctx.signal } },
    ).$inspect();

    if (!result.ok) {
      return {
        content: [{ type: "text", text: result.error.message }],
        isError: true,
      };
    }

    const value = result.value;

    return formatResult(value, apiCall);
  },
};
